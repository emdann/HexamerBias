---
title: "Estimation of scaling factor and equilibrium constants"
output: html_notebook
---
```{r}
## Chunk for knitting outside of Github
library(ezknitr)
ezknit(file = "eps_and_Keq_estimation_final.Rmd", out_dir = "~/AvOwork")
```

```{r, eval=F}
setwd("~/mnt/")
source("~/HexamerBias/deltaGprediction/binding_model_functions.r")
# source('~/HexamerBias/rscripts/hexamer_sequence_functions.r')
```

```{r}
load("~/AvOwork/rdata/human_pt_all.RData")
load("~/AvOwork/rdata/cele_pt_all.RData")
load("~/AvOwork/rdata/zfish_pt_all.RData")
load("~/AvOwork/rdata/human_pt.RData")
load("~/AvOwork/rdata/cele_pt.RData")
load("~/AvOwork/rdata/zf_pt.RData")
```

<!-- ## Before epsilon -->
<!-- In the previous version of the model, I predicted binding free energies for the primer-template binding reaction as follows: -->
<!-- $$ -->
<!-- exp(\Delta G_{ij})=\frac{p_it_j}{\sum_j{\sum_j{p_it_j}}}\cdot\frac{\sum_j{T_j}}{T_j - \sum_i{p_it_j}} -->
<!-- $$ -->
<!-- Here the normalization strategy is inappropriate, as $p_it_j$ count and the free template count ($T_j - \sum_i{p_it_j}$) are normalized on different factors.    -->

<!-- Recently we observed we could compute reasonable $\Delta$G values also removing the normalization factors and using the differnt variables as simple counts: -->
<!-- $$ -->
<!-- exp(\Delta G_{ij})=\frac{p_it_j}{T_j - \sum_i{p_it_j}} -->
<!-- $$ -->
<!-- ```{r} -->
<!-- cele.df %>% -->
<!--   filter(pt>200) %>% -->
<!--   mutate(pred.deltaG=pt/(abundance-t.usage)) %>% -->
<!--   ggplot(., aes(dG, log(pred.deltaG))) + -->
<!--   geom_point(alpha=0.3) -->


<!-- ``` -->



<!-- ## Estimation of scaling factor epsilon -->
<!-- We expect that the primer-template pairs that we measure are proportional but not equal to the real amount of pairs $[p_it_j]$ that we would expect by binding primers on one copy of the genome. That is because each sample might have a different copy number for the genome (because of a different number of cells, or loss of a chromosome etc...) and different sequencing depth. For this reason we define: -->
<!-- $$ -->
<!--   x_{ij}=\varepsilon[p_it_j], -->
<!-- $$ -->
<!-- where $\varepsilon$ is a scaling-factor that accounts for all sample specific effects. -->


<!-- #### Chi-square on multiple groups  -->
<!-- Using the chi-square approach on groups of sequences with the same $\Delta$G I estimate epsilon sampling 20 groups with at least 20 sequences from every genome.  -->

<!-- I can estimate epsilon using as primer concentration the probability distribution from a simulated random pool (requires taking the average of more iterations), or assuming the same concentration for each primer ($4/4^6$). As I don't see a significant difference between the two approaches, I chose to proceed assuming even primer concentration, which makes the estimation quicker. -->

<!-- <!-- ```{r} --> -->
<!-- <!-- cele.eps <-epsilon.iterative(cele.df, estimation.it = 40) --> -->
<!-- <!-- cele.eps.prob <-epsilon.iterative(cele.df, estimation.it = 30, sample.size = 10, imposeP = T) --> -->

<!-- <!-- # zf.eps <-epsilon.iterative(zf.df, estimation.it = 20) --> -->
<!-- <!-- # zf.eps.prob <-epsilon.iterative(zf.df, estimation.it = 40, sample.size = 10, imposeP = T) --> -->

<!-- <!-- mutate(melt(cele.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='cele.dist') %>% --> -->
<!-- <!--   bind_rows(., mutate(melt(cele.eps.prob, id.vars='n', variable.name='iteration', value.name = 'eps'), species='cele.prob')) %>% --> -->
<!-- <!--   # bind_rows(., mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf')) %>% --> -->
<!-- <!--   ggplot(., aes(eps, group=species, fill=species)) +  --> -->
<!-- <!--   facet_grid(species~.) + --> -->
<!-- <!--   geom_histogram()   --> -->

<!-- <!-- # mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf.dist') %>% --> -->
<!-- <!-- #   bind_rows(., mutate(melt(zf.eps.prob, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf.prob')) %>% --> -->
<!-- <!-- #   # bind_rows(., mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf')) %>% --> -->
<!-- <!-- #   ggplot(., aes(eps, group=species, fill=species)) +  --> -->
<!-- <!-- #   facet_grid(species~.) + --> -->
<!-- <!-- #   geom_histogram()   --> -->
<!-- <!-- ``` --> -->

<!-- ##### Estimation for all species with fixed probability -->
<!-- ```{r} -->
<!-- cele.eps <-epsilon.iterative(select.diag.pairs(cele.all.df), tot.it = 300, estimation.it = 1, sample.size = 10, imposeP = T) -->
<!-- zf.eps <-epsilon.iterative(select.diag.pairs(zf.all.df), tot.it = 300, estimation.it = 1, sample.size = 10, imposeP = T) -->
<!-- human.eps <-epsilon.iterative(select.diag.pairs(human.all.df), tot.it = 300,estimation.it = 1, sample.size = 10, imposeP = T) -->
<!-- ``` -->

<!-- ```{r, echo=F} -->
<!-- mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf') %>% -->
<!--   bind_rows(., mutate(melt(cele.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='cele')) %>% -->
<!--   bind_rows(., mutate(melt(human.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='human')) %>% -->
<!--   ggplot(., aes(eps, group=species, fill=species)) +  -->
<!--   facet_grid(species~.) + -->
<!--   xlab('epsilon') + -->
<!--   theme(axis.title=element_text(size=20), -->
<!--         axis.text=element_text(size=16), -->
<!--         strip.text=element_text(size=20), -->
<!--         legend.text = element_text(size=20), -->
<!--         legend.title = element_text(size=22)) + -->
<!--   geom_histogram()   -->

<!-- # ggsave("~/AvOwork/output/epsilon_estimate/eps_dist_groupChi_fixedP.pdf") -->
<!-- ``` -->

<!-- Interestingly the size of the sample of groups I take for the estimation affects the range of epsilons -->
<!-- ```{r} -->
<!-- cele.eps.3 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 3,imposeP = T) -->
<!-- cele.eps.4 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 4,imposeP = T) -->
<!-- cele.eps.5 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 5,imposeP = T) -->
<!-- cele.eps.10 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 10,imposeP = T) -->
<!-- cele.eps.15 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 15,imposeP = T) -->
<!-- cele.eps.20 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 20,imposeP = T) -->
<!-- cele.eps.25 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 25,imposeP = T) -->
<!-- cele.eps.30 <-epsilon.iterative(select.diag.pairs(cele.all.df), estimation.it = 20, sample.size = 30,imposeP = T) -->

<!-- mutate(melt(cele.eps.5, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=5) %>% -->
<!--   # bind_rows(., mutate(melt(cele.eps.3, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=3)) %>% -->
<!--   # bind_rows(., mutate(melt(cele.eps.4, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=4)) %>% -->
<!--   bind_rows(., mutate(melt(cele.eps.10, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=10)) %>% -->
<!--   bind_rows(., mutate(melt(cele.eps.15, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=15)) %>% -->
<!--   bind_rows(., mutate(melt(cele.eps.20, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=20)) %>% -->
<!--   bind_rows(., mutate(melt(cele.eps.25, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=25)) %>% -->
<!--   bind_rows(., mutate(melt(cele.eps.30, id.vars='n', variable.name='iteration', value.name = 'eps'), sample.size=30)) %>% -->
<!-- # bind_rows(., mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf')) %>% -->
<!--   ggplot(., aes(sample.size, eps, group=sample.size, fill=sample.size)) +  -->
<!--   # facet_grid(species~.) + -->
<!--   geom_violin() + -->
<!--   NULL -->
<!-- ``` -->

<!-- This observation made me try using the Chi-square approach on one group at a time to estimate epsilon.  -->

<!-- #### Chi-square on single groups  -->
<!-- The distribution is less defined (also because there are no iterations involved) -->
<!-- ```{r} -->
<!-- epsilons.cele <- sapply(seq(1,40), function(x) estimate.eps.one.group(cele.df, group = x)) -->
<!-- epsilons.human <- sapply(seq(1,40), function(x) estimate.eps.one.group(human.df, group = x)) -->
<!-- epsilons.zf <- sapply(seq(1,40), function(x) estimate.eps.one.group(zf.df, group = x)) -->

<!-- df.eps.single <- mutate(data.frame(t(epsilons.cele)), eps= as.numeric(eps), group=as.numeric(group)) %>% -->
<!--   inner_join(., mutate(data.frame(t(epsilons.human)), eps= as.numeric(eps), group=as.numeric(group)), by='group', suffix=c('.cele', '.human')) %>% -->
<!--   inner_join(., mutate(data.frame(t(epsilons.zf)), eps= as.numeric(eps), group=as.numeric(group)), by='group') %>% -->
<!--   rename(eps.zf=eps)  -->

<!-- df.eps.single %>% -->
<!--   melt(id.vars='group', variable.name='species', value.name='eps') %>% -->
<!--   ggplot(., aes(eps, fill=species)) + -->
<!--   facet_grid(species~.) + -->
<!--   geom_histogram(bins=40) -->
<!-- ``` -->

<!-- Also, the group of hexamers on which the estimation is made influences the outcome consistently between species -->
<!-- ```{r} -->
<!-- df.eps.single %>% -->
<!--   ggplot(., aes(eps.cele, eps.human, label=group)) + geom_text() + -->
<!--   theme(axis.title = element_text(size=20)) -->
<!-- ``` -->

<!-- ### Correlating epsilon with % of genome covered -->
<!-- Whatever the method of choice, the value of epsilon obtained is correlated with the overall genomic coverage. -->
<!-- I use ```bedtools genomecov``` to compute the percentage of genome covered for each experiment. -->

<!-- ```{r} -->
<!-- cov <- data.frame(species = c('cele', 'human', 'zf'), cov=c(1-0.0638419,1-0.754045,1-0.603038)) -->

<!-- species.epsilons<- mutate(melt(zf.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='zf') %>% -->
<!--   bind_rows(., mutate(melt(cele.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='cele')) %>% -->
<!--   bind_rows(., mutate(melt(human.eps, id.vars='n', variable.name='iteration', value.name = 'eps'), species='human')) %>%  -->
<!--   # melt(id.vars='group', variable.name='species', value.name='eps') %>% -->
<!--   mutate(species=gsub(species, pattern = 'eps.', replacement = '')) %>% -->
<!--   group_by(species) %>% -->
<!--   summarise(eps=median(eps, na.rm=T)) -->

<!-- species.eps.onegroup <- mutate(data.frame(groups=unlist(epsilons.zf[1,]), eps=unlist(epsilons.zf[2,])) , species='zf') %>% -->
<!--   bind_rows(., mutate(data.frame(groups=unlist(epsilons.human[1,]), eps=unlist(epsilons.human[2,])) , species='human')) %>% -->
<!--   bind_rows(., mutate(data.frame(groups=unlist(epsilons.cele[1,]), eps=unlist(epsilons.cele[2,])) , species='cele')) -->

<!-- species.eps.onegroup %>% -->
<!--   inner_join(., cov, by='species') %>% -->
<!--   filter(groups<10) %>% -->
<!--   ggplot(., aes(cov, eps, group=groups, color=groups)) + -->
<!--   # facet_wrap(~groups, scales='free_y') + -->
<!--   geom_point() + geom_line() -->

<!-- species.epsilons %>% inner_join(., cov, by='species') %>% -->
<!--   ggplot(., aes(cov,eps)) + geom_point() + -->
<!--   geom_smooth(method='loess') -->
<!-- ``` -->

<!-- (When the cluster is back) We could use a downsampling approach to see if computing epsilon on less reads we still get the same regression line, to be used to estimate epsilon in different experiments. -->


<!-- ## Estimation of $K_{eq}$ -->

<!-- Using the estimated value for epsilon, I compute the assciation constant $K_{eq}$ for template $j$ and primer $i$ as: -->
<!-- $$ -->
<!--   K_{ij} = [p_i]\left(\frac{\varepsilon T_j - \sum_ix_{ij}}{x_{ij}}\right) -->
<!-- $$ -->
<!-- Where $[p_i] = \frac{4}{4^6}$, $T_j$ is the fraction of genomic abundance for the template, $x_{ij}$ is the count of occurrencies for the primer-template pair $ij$. To improve the statistical power of the estimation, I assume that the association constant for primer $i$ on template $j$ is the same as the association constant for primer $j$ on template $i$, thereby taking the average of these two values. -->

<!-- First I filter out low count primer-template pairs (non relevant binding events) -->
<!-- ```{r} -->
<!-- cele.filt.df <- filter(cele.all.df, pt > 300) -->
<!-- human.filt.df <- filter(human.all.df, pt > 300) -->
<!-- zf.filt.df <- filter(zf.all.df, pt > 300) -->
<!-- ``` -->

<!-- Then I estimate $K_{eq}$ for all pairs -->
<!-- ```{r} -->
<!-- cele.keqs <- compute.keqs.fixedP(cele.filt.df, mean.eps = median(as.matrix(cele.eps[,-1]), na.rm=T), take.pairs = T) -->
<!-- zf.keqs <- compute.keqs.fixedP(zf.filt.df, mean.eps = median(as.matrix(zf.eps[,-1]), na.rm=T), take.pairs = T) -->
<!-- human.keqs <- compute.keqs.fixedP(human.filt.df, mean.eps = median(as.matrix(human.eps[,-1]), na.rm=T), take.pairs = T) -->
<!-- ``` -->

<!-- Comparison between $K_{eq}$ in different species -->
<!-- ```{r} -->
<!-- keqs <- zf.keqs %>% -->
<!--   dplyr::select(template, primer, pair,single.keq) %>% -->
<!--   inner_join(., dplyr::select(cele.keqs, template, primer, pair, single.keq), by=c('template', 'primer'), suffix=c('.zf', '.cele')) %>% -->
<!--   inner_join(., dplyr::select(human.keqs, template, primer, pair, single.keq), by=c('template', 'primer')) %>% -->
<!--   rename(single.keq.human=single.keq) %>% -->
<!--   group_by(pair) %>% -->
<!--   summarise(single.keq.human=mean(single.keq.human),single.keq.cele=mean(single.keq.cele), single.keq.zf=mean(single.keq.zf)) %>% -->
<!--   ungroup() %>% -->
<!--   mutate(nuc=sapply(pair, prevalent_nucleotide)) %>% -->
<!--   rename(K.human=single.keq.human, -->
<!--          K.cele=single.keq.cele, -->
<!--          K.zfish=single.keq.zf) -->

<!-- ``` -->

<!-- ```{r, echo=F} -->
<!-- cors <- cor(dplyr::select(keqs, K.human, K.cele, K.zfish) ) -->

<!-- keqs %>%   -->
<!--   ggplot(., aes(log(-K.cele), log(-K.zfish))) + -->
<!--   geom_point(alpha=0.4, aes(color=nuc)) + -->
<!--   theme_classic() + -->
<!--   geom_abline(slope=1, intercept=0, color='red') + -->
<!--   annotate('text',-4,-7,label=paste("PCC = ",round(cors['K.zfish','K.cele'],3)), size=6) + -->
<!--   theme(axis.title=element_text(size=20), -->
<!--         legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   scale_color_discrete(name="Prevalent nucleotide") + -->
<!--   NULL -->

<!-- keqs %>%   -->
<!--   ggplot(., aes(log(-K.human), log(-K.zfish))) + -->
<!--   geom_point(alpha=0.4, aes(color=nuc)) + -->
<!--   theme_classic() + -->
<!--   geom_abline(slope=1, intercept=0, color='red') + -->
<!--   annotate('text',-5,-7,label=paste("PCC = ",round(cors['K.zfish','K.human'],3)), size=6) + -->
<!--     theme(axis.title=element_text(size=20), -->
<!--         legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   scale_color_discrete(name="Prevalent nucleotide") + -->
<!--   NULL -->

<!-- keqs %>%   -->
<!--   ggplot(., aes(log(-K.cele), log(-K.human))) + -->
<!--   geom_point(alpha=0.4, aes(color=nuc)) + -->
<!--   theme_classic() + -->
<!--   geom_abline(slope=1, intercept=0, color='red') + -->
<!--   annotate('text',-5,-7,label=paste("PCC = ",round(cors['K.human','K.cele'],3)), size=6) + -->
<!--     theme(axis.title=element_text(size=20), -->
<!--         legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   scale_color_discrete(name="Prevalent nucleotide") + -->
<!--   NULL -->
<!-- ``` -->

<!-- Taking as final values mean between species -->
<!-- ```{r} -->
<!-- keqs.mean <- keqs %>% -->
<!--   dplyr::select(-nuc) %>% -->
<!--   # dplyr::select(pair,single.keq.cele, single.keq.human, single.keq.zf) %>% -->
<!--   melt(id.vars="pair", variable.name='species', value.name='keq') %>% -->
<!--   group_by(pair) %>% -->
<!--   summarise(mean.keq=mean(keq, na.rm=T), sd.keq=sd(keq, na.rm=T)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- write.csv(x = keqs.mean, "~/Keqs_all_pairs.csv") -->
<!-- ``` -->

<!-- #### Correlation of Keq with Mfold deltaG -->

<!-- ```{r} -->
<!-- pred.keq.cele <- add.pairs.info(cele.df) %>% -->
<!--   inner_join(., keqs.mean, by='pair')  -->
<!-- pred.keq.cele <- pred.keq.cele %>% -->
<!--     mutate(nuc=sapply(template, prevalent_nucleotide), -->
<!--          p=4/(4^6))  -->
<!-- pred.keq.cele %>% -->
<!--   mutate(nuc=sapply(template, prevalent_nucleotide), -->
<!--          p=4/(4^6)) %>% -->
<!--   ggplot(., aes(dG, log(-mean.keq/p), color=nuc)) + -->
<!--   geom_point(alpha=0.3) + -->
<!--       theme(axis.title=element_text(size=20), -->
<!--         legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   xlab('DeltaG MFold') + -->
<!--   scale_color_discrete(name="Prevalent nucleotide") + -->
<!--   NULL -->

<!-- ``` -->

<!-- One immediate observation is that the range for the predicted $\Delta$G is quite smaller than the MFold. -->

<!-- ## Coverage prediction in no-BS -->
<!-- I use my model and the predicted $K_{eq}$ values and epsilon to estimate template usage (coverage) as: -->
<!-- $$ -->
<!-- C^\prime_j = \varepsilon \cdot T_j\frac{\sum_i\frac{[p_i]}{K_{ij}}}{1+\sum_i\frac{[p_i]}{K_{ij}}} -->
<!-- $$ -->

<!-- ```{r} -->
<!-- pred.keq.cele %>% -->
<!--   mutate(abundance=abundance/sum(abundance)) %>% -->
<!--   mutate(phi=p/-mean.keq, -->
<!--          nuc=sapply(template, prevalent_nucleotide), -->
<!--          epsilon=median(as.matrix(cele.eps[,-1]), na.rm=T)) %>% -->
<!--   group_by(template) %>% -->
<!--   summarise(abundance=first(abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi), nuc=first(nuc)) %>% -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)), color=nuc)) + geom_point(alpha=0.2) + -->
<!--   xlab("log(expected cov)") + ylab('log(predicted cov)') + -->
<!--     scale_color_discrete(name="Prevalent nucleotide") + -->
<!--         theme(axis.title=element_text(size=20), -->
<!--         # legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   NULL -->

<!-- ``` -->

<!-- ## Coverage prediction in BS-seq experiments -->

<!-- I estimate epsilon for the BS experiment based on the % of genomic coverage in the experiment.  -->
<!-- ```{r} -->
<!-- load("~/AvOwork/rdata/D3R_pt.RData") -->
<!-- lm.epsilon <- species.epsilons %>%  -->
<!--   inner_join(., cov, by='species') %>% -->
<!--   lm(eps ~ cov, data=.) -->

<!-- perc.d3R <- 1-0.951344 -->
<!-- eps.d3r <- predict.lm(lm.epsilon,data.frame(cov=c(perc.d3R)))  -->

<!-- d3r.filt.df <- d3r.all.df %>% filter(pt>10)  -->
<!-- d3r.keqs <- compute.keqs.fixedP(d3r.filt.df, mean.eps = eps.d3r, take.pairs = T) -->

<!-- ``` -->

<!-- <!-- Reproducibility of binding events between BS-experiments --> -->
<!-- <!-- ```{r} --> -->
<!-- <!-- join.DR <- d2r.all.df %>% --> -->
<!-- <!--   filter(pt!=0) %>% --> -->
<!-- <!--   dplyr::select(primer, template, t.usage, pt, abundance) %>% --> -->
<!-- <!--   inner_join(., dplyr::select(d3r.filt,primer, template, t.usage, pt), by=c('primer', 'template'), suffix=c('.D2R', '.D3R'))  --> -->
<!-- <!-- head(join.DR) --> -->
<!-- <!-- join.DR %>% --> -->
<!-- <!--   ggplot(., aes(log(t.usage.D2R), log(t.usage.D3R))) +  --> -->
<!-- <!--   geom_point(alpha=0.3) --> -->
<!-- <!--   # ggplot(., aes(t.usage.D2R, t.usage.D3R)) + geom_point(alpha=0.3) --> -->
<!-- <!-- ``` --> -->

<!-- <!-- Then I can pool the two repliate experiments --> -->
<!-- <!-- ```{r} --> -->
<!-- <!-- pooled.DR <- join.DR %>% --> -->
<!-- <!--   mutate(pt=pt.D2R+pt.D3R, t.usage=t.usage.D2R+t.usage.D3R) %>% --> -->
<!-- <!--   dplyr::select(primer, template, pt,t.usage, abundance) --> -->

<!-- <!-- pooled.DR %>% --> -->
<!-- <!--   filter(pt>30) %>% --> -->
<!-- <!--   nrow --> -->

<!-- <!-- join.DR %>% --> -->
<!-- <!--   filter(grepl("C", template))  --> -->

<!-- <!-- dr.pooled.keqs <- compute.keqs.fixedP(filter(pooled.DR, pt>10), mean.eps = eps.d3r, take.pairs = F)  --> -->

<!-- <!-- dr.pooled.keqs %>% --> -->
<!-- <!--   mutate(p = 4/4^6) %>% --> -->
<!-- <!--   # mutate(abundance=abundance/sum(abundance)) %>% --> -->
<!-- <!--   mutate(phi=p/-single.keq) %>% --> -->
<!-- <!--   # head --> -->
<!-- <!--     group_by(template) %>% --> -->
<!-- <!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon*2), t.usage=first(t.usage), sum.phi=sum(phi)) %>% --> -->
<!-- <!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% --> -->
<!-- <!--   ggplot(., aes(log(t.usage), log(pred.cov))) + geom_point(alpha=0.2) --> -->
<!-- <!-- ``` --> -->

<!-- When predicting the coverage first of all I find templates with a negative predicted coverage. -->
<!-- ```{r} -->
<!-- d3r.keqs %>% -->
<!--   # mutate(p = 4/4^6) %>% -->
<!--   filter(pt>10) %>% -->
<!--   # mutate(abundance=abundance/sum(abundance)) %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--   # ggplot(., aes(phi)) + geom_histogram(bins=40) -->
<!--     group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--     # ggplot(., aes(sum.phi)) + geom_histogram(bins=40) -->
<!--   # group_by(template) %>% -->
<!--   # # mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n')) %>% -->
<!--   # ggplot(., aes(log(t.usage/sum(t.usage)), log(abundance/sum(abundance)))) +  -->
<!--   ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)))) + -->
<!--   theme_classic() + -->
<!--   geom_point(alpha=0.4, aes(color=nuc, shape=CG)) + -->
<!--     # ggplot(., aes(log(t.usage), log(pred.cov))) +  -->
<!--   xlab("expected cov") + ylab('predicted cov') + -->
<!--     scale_color_discrete(name="Prevalent nucleotide") + -->
<!--         theme(axis.title=element_text(size=20), -->
<!--         # legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   geom_abline(slope=1, intercept=0, color='red')  -->
<!-- ```  -->

<!-- This has to do with the value of epsilon. Trying a smaller value of epsilon (absolutely not in line with the genomic coverage hypothesis) solves the issue but the correlation is still poor. -->
<!-- ```{r} -->
<!-- d3r.keqs <- compute.keqs.fixedP(d3r.filt.df, mean.eps = 1000, take.pairs = T) -->

<!-- d3r.keqs %>% -->
<!--   filter(pt>10) %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--     group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n')) %>% -->
<!--   ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)))) + -->
<!--   theme_classic() + -->
<!--   geom_point(alpha=0.4, aes(color=nuc, shape=CG)) + -->
<!--   xlab("log(expected cov)") + ylab('log(predicted cov)') + -->
<!--     scale_color_discrete(name="Prevalent nucleotide") + -->
<!--         theme(axis.title=element_text(size=20), -->
<!--         # legend.position = 'bottom', -->
<!--         legend.title = element_text(size=20), -->
<!--         legend.text = element_text(size=18)) + -->
<!--   geom_abline(slope=1, intercept=0, color='red')  -->
<!-- ``` -->

<!-- All in all, given the dependence of the epsilon estimation on the sampling and groups and these issues in the BS-seq estimation, I would say that this approach for estimating epsilon and $K_{eq}$ is really introducing a lot of numerical errors that we could exclude using relative energies.x -->

<!-- ## MORE ON THIS -->


<!-- ```{r} -->
<!-- epsilons.cele <- sapply(seq(1,40), function(x) estimate.eps.one.group(cele.df, group = x)) -->
<!-- epsilons.human <- sapply(seq(1,40), function(x) estimate.eps.one.group(human.df, group = x)) -->
<!-- epsilons.zf <- sapply(seq(1,40), function(x) estimate.eps.one.group(zf.df, group = x)) -->

<!-- species.eps.onegroup <- mutate(data.frame(groups=unlist(epsilons.zf[1,]), eps=unlist(epsilons.zf[2,])) , species='zf') %>% -->
<!--   bind_rows(., mutate(data.frame(groups=unlist(epsilons.human[1,]), eps=unlist(epsilons.human[2,])) , species='human')) %>% -->
<!--   bind_rows(., mutate(data.frame(groups=unlist(epsilons.cele[1,]), eps=unlist(epsilons.cele[2,])) , species='cele')) -->

<!-- epsil.onegroup <- species.eps.onegroup %>% group_by(species) %>% summarise(eps=median(eps, na.rm = T)) -->


<!-- epsil.onegroup %>% -->
<!--   inner_join(., cov, by='species') %>% -->
<!-- # Ã‡  filter(groups<10) %>% -->
<!--   ggplot(., aes(cov, eps)) + -->
<!--   # facet_wrap(~groups, scales='free_y') + -->
<!--   geom_point() + geom_line() -->
<!-- ``` -->

<!-- ```{r} -->

<!-- cele.keqs <- compute.keqs.fixedP.totabundance(cele.filt.df, mean.eps = filter(epsil.onegroup, species=='cele')$eps, take.pairs = T) -->
<!-- zf.keqs <- compute.keqs.fixedP.totabundance(zf.filt.df, mean.eps = filter(epsil.onegroup, species=='zf')$eps, take.pairs = T) -->
<!-- human.keqs <- compute.keqs.fixedP.totabundance(human.filt.df, mean.eps = filter(epsil.onegroup, species=='human')$eps, take.pairs = T) -->

<!-- keqs <- zf.keqs %>% -->
<!--   dplyr::select(template, primer, pair,single.keq) %>% -->
<!--   inner_join(., dplyr::select(cele.keqs, template, primer, pair, single.keq), by=c('template', 'primer'), suffix=c('.zf', '.cele')) %>% -->
<!--   inner_join(., dplyr::select(human.keqs, template, primer, pair, single.keq), by=c('template', 'primer')) %>% -->
<!--   rename(single.keq.human=single.keq) %>% -->
<!--   group_by(pair) %>% -->
<!--   summarise(single.keq.human=mean(single.keq.human),single.keq.cele=mean(single.keq.cele), single.keq.zf=mean(single.keq.zf)) %>% -->
<!--   ungroup() %>% -->
<!--   mutate(nuc=sapply(pair, prevalent_nucleotide)) %>% -->
<!--   rename(K.human=single.keq.human, -->
<!--          K.cele=single.keq.cele, -->
<!--          K.zfish=single.keq.zf) -->
<!-- ``` -->


## YET ANOTHER EPSILON ESTIMATION
We search for the value of the scaling factor $\epsilon$ that minimizes the difference between the expected association constant ($e^{-\beta\Delta G}$, taking $\Delta$G values from calorimetry). To avoid numerical errors in the estimation we transform all factors to logarithms. 
$$
\chi^2 = \sum{\left( K_{ij} - log([p]) + log\left(T_j - \frac{\sum_i{x_{ij}}}{\epsilon}\right) + log\left(\frac{x_{ij}}{\epsilon}\right)\right)^2}
$$

Where we fix that the concentration of total template should also be higher than the concentration of bound template:
$$
T_j - \frac{\sum_i{x_{ij}}}{\epsilon} > 0
\epsilon > \frac{\sum_i{x_{ij}}}{T_j}
$$

```{r, eval=F}
eps.human <- epsilon.minimize.chisq(human.df, max=10000, plot=F)
eps.zf <- epsilon.minimize.chisq(zf.df, max=15000, plot=F)
eps.cele <- epsilon.minimize.chisq(cele.df, min=130000, max=140000, plot=F)
```

#### Correlation with genomic coverage
I compute percentage of genome covered using `bedtools genomecov`

```{r}
genome.cov <- data.frame(species = c('cele', 'human', 'zf'), cov=c(1-0.0638419,1-0.754045,1-0.603038))

genome.cov %>%
  bind_cols(eps=c(eps.cele, eps.human, eps.zf)) %>%
  ggplot(., aes(log(cov), log(eps), label=species)) + 
  geom_point() +
  geom_text_repel()
```


#### Keq estimation
```{r}
# compute.keqs <- function(pt.df, eps, filter.pt=200){
#   keqs <- pt.df %>%
#     filter(pt>filter.pt) %>%
#     mutate(keq=((4^6)/4)*(pt/(eps*abundance-t.usage))) 
#   return(keqs)
#   }

human.keqs <- compute.keqs(human.all.df, eps.human, filter.pt = 0)
zf.keqs <- compute.keqs(zf.all.df, eps.zf, filter.pt = 0)
cele.keqs <- compute.keqs(cele.all.df, eps.cele, filter.pt = 0)
```

Correlation between predicted keqs
```{r}
join.df <- 
  inner_join(zf.keqs, human.keqs, by=c('template', 'primer'), suffix=c('.zf', '.human')) %>%
  # filter(primer==template) %>%
  mutate(mm=ifelse(primer==template, 'match', 'mismatch')) 
pcc <- cor(join.df$keq.zf, join.df$keq.human)
join.df %>%
  ggplot(., aes(log(keq.zf), log(keq.human), color=mm)) +
  geom_point(alpha=0.2, size=0.7) +
  theme_classic() +
  annotate("text",x = -9, y=-15, label=paste("PCC =",round(pcc, 3)), size=9) +
  geom_abline(slope=1, intercept=0, color='red') +
  scale_color_brewer(palette = "Paired",type = "qual") +
    theme(legend.title = element_blank(),
        legend.text = element_text(size=20),
        axis.text = element_text(size=20),
        axis.title = element_text(size=30)) +
  xlab("Predicted Keq - D.rerio") + ylab("Predicted Keq - H.sapiens") +
    coord_fixed(ratio=1) +
  ggsave("~/AvOwork/output/epsilon_estimate/keq_cor_zfVShuman.pdf")

join.df <- 
  inner_join(cele.keqs, human.keqs, by=c('template', 'primer'), suffix=c('.cele', '.human')) %>%
  # filter(primer==template) %>%
  mutate(mm=ifelse(primer==template, 'match', 'mismatch')) 
pcc <- cor(join.df$keq.cele, join.df$keq.human)
join.df %>%
  ggplot(., aes(log(keq.cele), log(keq.human), color=mm)) +
  geom_point(alpha=0.2, size=0.7) +
  theme_classic() +
  annotate("text",x = -9, y=-15, label=paste("PCC =",round(pcc, 3)), size=9) +
  geom_abline(slope=1, intercept=0, color='red') +
  scale_color_brewer(palette = "Paired",type = "qual") +
    theme(legend.title = element_blank(),
        legend.text = element_text(size=20),
        axis.text = element_text(size=20),
        axis.title = element_text(size=30)) +
  xlab("Predicted Keq - C.elegans") + ylab("Predicted Keq - H.sapiens") +
    coord_fixed(ratio=1) 
  ggsave("~/AvOwork/output/epsilon_estimate/keq_cor_celeVShuman.pdf")

join.df <- 
  inner_join(cele.keqs, zf.keqs, by=c('template', 'primer'), suffix=c('.cele', '.zf')) %>%
  # filter(pt.cele>100 & pt.zf >100) %>%
  mutate(mm=ifelse(primer==template, 'match', 'mismatch')) 
pcc <- cor(join.df$keq.cele, join.df$keq.zf)
join.df %>%
  ggplot(., aes(log(keq.cele), log(keq.zf), color=mm)) +
  geom_point(alpha=0.2, size=0.7) +
  theme_classic() +
  annotate("text",x = -9, y=-15, label=paste("PCC =",round(pcc, 3)), size=9) +
  geom_abline(slope=1, intercept=0, color='red') +
  scale_color_brewer(palette = "Paired",type = "qual") +
    theme(legend.title = element_blank(),
        legend.text = element_text(size=20),
        axis.text = element_text(size=20),
        axis.title = element_text(size=30)) +
  xlab("Predicted Keq - C.elegans") + ylab("Predicted Keq - D.rerio") +
  coord_fixed(ratio=1) 
ggsave("~/AvOwork/output/epsilon_estimate/keq_cor_celeVSzf.pdf")

```

###### Is the correlation between Ks higher than the correlation between kmer abundance in the different genomes?
```{r}
ab.df <- list(cele.df, human.df, zf.df) %>%
  map(select, template, abundance) %>%
  reduce(full_join, by='template') 
  

cor((as.matrix(ab.df[,2:4])))


pt.df <- list(cele.df, human.df, zf.df) %>%
  map(select, template, pt) %>%
  reduce(full_join, by='template') 

  
pheatmap(cor(as.matrix(pt.df[,2:4])))
ab.df
```

### Impact of epsilon on Keq
```{r}
load("~/AvOwork/rdata/human_pt_all.RData")

ep.100 <- human.all.df %>%
  compute.keqs(filter.pt = 0, eps=100) %>%
  filter(template==primer)

ep.10 <- human.all.df %>%
  compute.keqs(filter.pt = 0, eps=1000) %>%
  filter(template==primer)

ep.10 %>%
  mutate(t=t.usage/abundance) %>%
  arrange(-t)

inner_join(ep.10, ep.100, by='template') %>%
  ggplot(., aes(keq.x, keq.y)) +
  geom_point(alpha=0.3)

ep.100 %>%
  mutate(cd=cume_dist(keq)) %>%
  ggplot(., aes(keq, cd)) +
  geom_point(size=0.5)

```

##### Correlation with MFold values
```{r}

avg.keqs <- inner_join(select(filter(human.keqs, pt>0), primer, template, keq, dG, pt), select(filter(cele.keqs, pt>0), primer, template, keq, pt), by=c('primer', 'template'), suffix=c('.human', '.cele')) %>%
inner_join(., select(filter(zf.keqs, pt>0), primer, template, keq, pt), by=c('primer', 'template')) %>%
  rename(pt.zf=pt) 
a <- avg.keqs %>%
  melt(id.vars=c('primer', 'template', 'dG', 'pt.zf', 'pt.human', 'pt.cele')) %>%
  group_by(primer, template) %>%
  summarise(avg.keq=mean(value, na.rm=T), dG=first(dG), pt.zf=first(pt.zf), pt.human=first(pt.human), pt.cele=first(pt.cele)) %>%
  ungroup() 
# 
# cele.keqs %>%
a %>%
  filter(primer==template) %>%
  filter(pt.zf>200 & pt.human>200 & pt.cele>200) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
  ggplot(., aes(dG, -log(keq), color=nuc)) + 
  geom_point(alpha=0.4, size=2)+
  theme_classic() +
      theme(legend.title = element_blank(),
        legend.text = element_text(size=20),
        axis.text = element_text(size=20),
        axis.title = element_text(size=30),
        title = element_text(size=30)) +
  xlab("MFold Delta G") + ylab("log(estimated Keq)") +
  ggtitle("Filtered pt > 200") +
  coord_fixed(ratio=2) +
  geom_smooth(method='lm', aes(color=NULL), size=1.5) +
  stat_cor(aes(color=NULL))
  # coord_fixed(ratio=1) 
  NULL

ggsave("~/AvOwork/output/epsilon_estimate/keq_mfold_avg_filt200.pdf")

```

#### Coverage prediction
```{r}
predict.coverage <- function(keqs.df, eps, prob=4/(4^6)){
  pred.cov <- keqs.df %>%
    mutate(p=prob) %>%
    mutate(phi=p*keq,
           nuc=sapply(template, prevalent_nucleotide),
           epsilon=eps) %>%
    group_by(template) %>%
    summarise(abundance=first(abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi), nuc=first(nuc)) %>%
    mutate(pred.cov=epsilon*abundance*(sum.phi/1+sum.phi)) 
  return(pred.cov)
  }

# human.keqs <- compute.keqs(human.df, eps.human, filter.pt = 50)
# zf.keqs <- compute.keqs(zf.df, eps.zf, filter.pt = 50)
# cele.keqs <- compute.keqs(cele.df, eps.cele, filter.pt = 50)

predict.coverage(filter(human.keqs), eps=eps.human) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage), log(pred.cov), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("Human - no BS") 

predict.coverage(zf.keqs, eps.zf) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage), log(pred.cov), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("Zebrafish - no BS")

predict.coverage(filter(cele.keqs, pt>100), eps.cele) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("C.elegans - no BS")

pred.cov.cele.unfilt %>% 
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("C.elegans - no BS")

pred.cov.cele.filt %>% 
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage), log(pred.cov), color=nuc)) + 
  geom_point(alpha=0.4) +
  # geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("C.elegans - no BS")

pred.cov.cele.filt <- predict.coverage(filter(cele.keqs, pt>100), eps.cele)
pred.cov.cele.unfilt <- predict.coverage(filter(cele.keqs, pt>2), eps.cele)
cor(pred.cov.cele.filt$pred.cov, pred.cov.cele.filt$t.usage)



```

There is a general underestimation of A rich hexamers. This is expected because we filter out primer-template events that occur less than a set number of times and we've seen that A rich hexamers tend to be bound weakly by a wide range of hexamers.

#### Is epsilon useful to filter less or is it just the logs?
```{r}
cele.keqs.noeps <- compute.keqs.noeps(cele.all.df, filter.pt = 10)
cele.keqs <- compute.keqs(cele.all.df, eps.cele, filter.pt = 10)

cele.keqs %>%
  inner_join(., cele.keqs.noeps, by=c('template', 'primer')) %>%
  ggplot(., aes(keq.x, keq.y)) + geom_point(alpha=0.2)

pred.cov.cele.noeps <- predict.coverage.noeps(cele.keqs.noeps)
pred.cov.cele.unfilt <- predict.coverage(cele.keqs, eps.cele)

pred.cov.cele.unfilt %>% 
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("C.elegans - no BS")

pred.cov.cele.noeps %>% 
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(t.usage)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("C.elegans - no BS")

```


### Estimate epsilon in BS-seq experiments
To estimate espilon in BS-seq experiments we use the same Chi-square approach as described abouve but using only templates that do not contain any Cs, that are not affected by bisulfite conversion. 
```{r}
load("~/AvOwork/rdata/D3R_pt.RData")

d3r.noC <- d3r.all.df %>%
  filter(template==primer) %>%
  filter(!grepl(template, pattern = "C"))
  
eps.d3r <- epsilon.minimize.chisq(d3r.noC, max=1000)
```

Is this value in line with genomic coverage? I redo epsilon estimation for the non converted samples using only hexamers with no Cs.
```{r}
perc.d3R <- 1-0.951344

human.noC <- human.df %>%
   filter(!grepl(template, pattern = "C")) 

zf.noC <- zf.df %>%
   filter(!grepl(template, pattern = "C")) 

cele.noC <- cele.df %>%
   filter(!grepl(template, pattern = "C")) 

chi.human.onlyC <- epsilon.minimize.chisq(human.noC, max=5000)
chi.zf.onlyC <- epsilon.minimize.chisq(zf.noC, max=10000)
chi.cele.onlyC <- epsilon.minimize.chisq(cele.noC, max=15000)

genome.cov %>%
  bind_rows(data.frame(species="mouse.BS", cov=perc.d3R)) %>%
  bind_cols(eps=c(chi.cele.onlyC, chi.human.onlyC, chi.zf.onlyC, eps.d3r)) %>%
  ggplot(., aes(log(cov), log(eps))) + 
  geom_point() +
  geom_text_repel(aes(label=species))

```


#### Coverage prediction in BS-seq
```{r}
d3r.keqs <- d3r.all.df %>%
  filter(pt>=10) %>%
  mutate(keq=((4^6)/4)*(pt/( eps.d3r*abundance-t.usage))) 

predict.coverage(d3r.keqs, eps.d3r) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) %>%
    ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("Mouse - BS")


```

Probably with less reads you also have less unspecific binding.

#### Coverage prediction with variable primer concentration
Load data for D2
```{r, echo=F}
setwd("~/mnt/edann/primer_conc_VAN2493/")
D2G <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D2G_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv")
D2T <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D2T_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv")
D2R <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D2R_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv")
```
```{r}
mm10.abundance <- load.kmer.abundance("~/mnt/edann/hexamers/genomes_kmers/mm10.kmerAbundance.csv")
mfold.dg <- load.modelled.deltaG("~/mnt/edann/hexamers/rand_hex_deltaG_ions.txt.gz")
d2g.all.df <- join.pt.data(D2G$matches, D2G$t.usage, mm10.abundance, mfold.dg)
d2t.all.df <- join.pt.data(D2T$matches, D2T$t.usage, mm10.abundance, mfold.dg)
d2r.all.df <- join.pt.data(D2R$matches, D2R$t.usage, mm10.abundance, mfold.dg)
```

```{r}
save(d2g.all.df, file="~/AvOwork/rdata/D2G_pt_all.RData")
save(d2t.all.df, file="~/AvOwork/rdata/D2T_pt_all.RData")

```

Epsilon estimation
```{r}
prob.t <- batch.prob.uniform(nuc.probs = c(pA=0.25, pT=0.45, pC=0.25, pG=0.05))
prob.g <- batch.prob.uniform(nuc.probs = c(pA=0.25, pT=0.05, pC=0.25, pG=0.45))

d2g.noC <- d2g.all.df %>%
  filter(template==primer) %>%
  filter(!grepl(template, pattern = "C"))
  
eps.d2g <- epsilon.minimize.chisq(d2g.noC, max=0.0052, primer.prob=prob.g, step=0.0000001)

d2t.noC <- d2t.all.df %>%
  filter(template==primer) %>%
  filter(!grepl(template, pattern = "C"))
  
eps.d2t <- epsilon.minimize.chisq(d2t.noC,  max=0.0007495, primer.prob=prob.t, step=0.0000000001)
```

```{r}
d2g.keqs <- 
  rownames_to_column(data.frame(prob.g), var = 'primer') %>%
  rename(p=prob.g) %>%
  inner_join(., d2g.all.df, by='primer') %>%
  filter(pt>=10) %>%
  mutate(keq=(4/p)*(pt/( eps.d2g*abundance-t.usage))) 

d2t.keqs <- 
  rownames_to_column(data.frame(prob.t), var = 'primer') %>%
  rename(p=prob.t) %>%
  inner_join(., d2t.all.df, by='primer') %>%
  filter(pt>=10) %>%
  mutate(keq=(p/4)*(pt/(eps.d2t*abundance-t.usage))) 

d2g.pred.cov <- predict.coverage(d2g.keqs, eps.d2g) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) 

d2g.pred.cov %>%  
  ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("Mouse - more G - BS")

d2t.pred.cov <- predict.coverage(d2t.keqs, eps.d2t) %>%
  mutate(nuc=sapply(template, prevalent_nucleotide)) 

d2t.pred.cov %>%
    ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)), color=nuc)) + 
  geom_point(alpha=0.4) +
  # geom_abline(slope=1, intercept=0, color='red') +
  theme_classic() +
  xlab("expected cov") + ylab("predicted cov") +
  ggtitle("Mouse - more T - BS")

```


#### Understanding epsilon
How does this guy change with alpha and beta? 
Alpha (seq efficiency) will be between 0 and 1 
beta (no. of cells) will be between 1 and 10000...

```{r}
alpha <- seq(0,1,by = 0.01)
beta <- c(1,100,1000,10000,1000000)


```


<!-- # Selection of filtering cut-off -->
<!-- Based on reproducibility of primer-template counts across different biological replicates -->
<!-- ```{r} -->
<!-- d2r.diag.df <- select.diag.pairs(d2r.all.df)  -->
<!-- d2r.diag.df <- select.diag.pairs(d2r.all.df)  -->
<!-- dr.diag <- d3r.all.df %>% -->
<!--   dplyr::select(template, primer, pt) %>% -->
<!--   inner_join(., dplyr::select(d2r.all.df, template, primer, pt), by=c('template', 'primer'), suffix=c(".D3", '.D2'))  -->

<!-- dr.diag %>%   -->
<!--   ggplot(., aes(log(pt.D2/sum(pt.D2)), log(pt.D3/sum(pt.D3)))) + geom_point(alpha=0.3) + -->
<!--     theme_classic() + -->
<!--     coord_fixed(ratio=1) + -->
<!--     # geom_smooth(method='lm', color='blue') + -->
<!--     geom_abline(slope=1, intercept=0, color='red') -->

<!-- dr.diag %>% -->
<!--   mutate(pt.D2= pt.D2/sum(pt.D2), pt.D3= pt.D3/sum(pt.D3)) %>% -->
<!--   filter(pt.D2!=0 & pt.D3!=0) %>% -->
<!--   mutate(a=(pt.D3-pt.D2)/pt.D2) %>% -->
<!--   melt(id.vars=c('template', 'primer', 'a'), variable.name='rep', value.name='pt') %>% -->
<!--   ggplot(., aes(pt, a)) +  -->
<!--   facet_grid(rep~.) + -->
<!--   geom_point() + -->
<!--   geom_vline(xintercept =0.0025, color='blue', linetype=5) + -->
<!--   ylab("Residuals") + xlab("pt fraction") -->

<!-- ``` -->



<!-- ## Estimation from BS seq experiments -->
<!-- Loading data -->
<!-- ```{r} -->
<!-- kmer.ab.mouse <- load.kmer.abundance('~/mnt/edann/hexamers/genomes_kmers/mm10.kmerAbundance.csv') -->

<!-- d2r.all <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D2R_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv") -->
<!-- d2r.all.df <- join.pt.data(d2r.all$matches, d2r.all$t.usage, kmer.ab.mouse, tabDg) -->

<!-- d3r.all <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D3R_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv") -->
<!-- d3r.all.df <- join.pt.data(d3r.all$matches, d3r.all$t.usage, kmer.ab.mouse, tabDg) -->

<!-- d3t.all <- load.pt.data("~/mnt/edann/primer_conc_VAN2493/D3T_tr2_R1_bismark_bt2.ptCounts.qualFilt.csv") -->
<!-- d3t.all.df <- join.pt.data(d3r.all$matches, d3r.all$t.usage, kmer.ab.mouse, tabDg) -->


<!-- ``` -->

<!-- I want to prove that epsilon is proportional to the genomic coverage (how much of the genome do you cover). -->

<!-- Let's see how Keq changes for different values of epsilon -->
<!-- ```{r} -->

<!-- variable.eps <- function(pt.df, eps){ -->
<!--   cele.keqs <-   mutate(pt.df,   -->
<!--                   p=4/(4^6), -->
<!--                   epsilon=eps, -->
<!--                   frac.abundance=(abundance/sum(as.numeric(abundance))) -->
<!--                   ) %>% -->
<!--     mutate(single.keq=p*((epsilon*(frac.abundance/pt))-(t.usage/pt)))  -->
<!--     # summarize(mean.k=mean(single.keq)) -->
<!--   chi <- cele.keqs %>% -->
<!--     mutate(chi=dG-log(-single.keq)) %>% -->
<!--     summarize(chi=sum(chi)) -->
<!--   return(c(e,cele.keqs$mean.k)) -->
<!--   } -->

<!-- chi.sq <- c() -->
<!-- for (e in sapply(-10:2, function(x) 10^x)) { -->
<!--   chi.sq <- rbind(chi.sq, variable.eps(cele.filt.df, e))   -->
<!-- } -->

<!-- as.data.frame(chi.sq) %>% -->
<!--   rename(eps=V1, chi.sq=V2) %>% -->
<!-- # ggplot(., aes(log10(log10.eps), log(-chi.sq+1))) + -->
<!--   ggplot(., aes(eps, -chi.sq)) + -->
<!--   geom_line() + -->
<!--   theme_classic() -->

<!-- chi.sq -->
<!-- ``` -->



<!-- Coverage prediction in no-BS -->
<!-- ```{r} -->
<!-- cele.pred.cov <- cele.keqs %>% -->
<!--   mutate(abundance=abundance/sum(abundance)) %>% -->
<!--   # mutate(phi=p/-single.keq) %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--   # ggplot(., aes(phi)) + geom_histogram(bins=40) -->
<!--   group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--     mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n')) %>% -->
<!--   # ggplot(., aes(sum.phi)) + geom_histogram(bins=40) -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi))))  -->
<!--   # ggplot(., aes(log(t.usage/sum(t.usage)), log(abundance/sum(abundance)))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->

<!-- cele.pred.cov %>% -->
<!--   ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->

<!-- cele.pred.cov %>% -->
<!--   ggplot(., aes(log(t.usage), log(abundance))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->



<!-- zf.pred.cov <- zf.keqs %>% -->
<!--   mutate(abundance=abundance/sum(abundance)) %>% -->
<!--   # mutate(phi=p/-single.keq) %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--   # ggplot(., aes(phi)) + geom_histogram(bins=40) -->
<!--   group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--     mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n')) %>% -->
<!--   # ggplot(., aes(sum.phi)) + geom_histogram(bins=40) -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(pred.cov.frac=pred.cov/sum(pred.cov)) -->
<!--   # ggplot(., aes(log(t.usage/sum(t.usage)), log(abundance/sum(abundance)))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->
<!-- zf.pred.cov %>% -->
<!--   ggplot(., aes(log(t.usage/sum(t.usage)), log(pred.cov/sum(pred.cov)))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->

<!-- zf.pred.cov %>% -->
<!--   ggplot(., aes(log(t.usage/sum(t.usage)), log(abundance/sum(abundance)))) + geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->

<!-- summary(lm(log(t.usage) ~ log(pred.cov.frac), data=zf.pred.cov)) -->
<!-- summary(lm(log(t.usage) ~ log(abundance), data=zf.pred.cov)) -->
<!-- ``` -->
<!-- ```{r} -->
<!-- primer.usage.cele <- cele.all.df %>% -->
<!--   group_by(primer) %>% -->
<!--   summarise(p.usage= sum(pt)) %>% -->
<!--   rename(hex=primer) -->

<!-- cele.df %>% -->
<!--   dplyr::select(template, t.usage,pt, abundance) %>% -->
<!--   rename(hex=template) %>% -->
<!--   inner_join(., primer.usage.cele, by='hex') %>% -->
<!--   mutate(nuc=sapply(hex,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', hex), 'y', 'n')) %>% -->
<!--   ggplot(., aes(log(t.usage), log(p.usage))) + -->
<!--   geom_point(alpha=0.4, aes(color=nuc, shape=CG)) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- prob <- table(simulate.primer.pool(pool.size=100000, pG=0.05, pT=0.45))/100000 -->
<!-- prob.df <- rename(data.frame(prob), primer=Var1, p=Freq) -->

<!-- prob <- sapply(unique(cele.df$template), primer.prob, probs=c(A=0.25, C=0.25, G=0.05, T=0.45)) -->
<!-- prob.df <- as.data.frame(prob,row.names = F)  -->
<!-- prob.df <- mutate(prob.df, primer=rownames(prob.df)) %>%   -->
<!--   rename(p=prob) -->

<!-- df <- dr.pooled.keqs %>% -->
<!--   dplyr::select(template, primer, single.keq, epsilon) %>% -->
<!--   inner_join(., d3t.all.df, by=c('template', 'primer') ) %>% -->
<!--   inner_join(., prob.df, by=c('primer') ) %>% -->
<!--   mutate(p = 4/p) %>% -->
<!--   mutate(frac.abundance=abundance/tot.ab) %>% -->
<!--   filter(pt>15)  -->
<!--   # mutate(abundance=abundance/sum(abundance)) %>% -->
<!-- df %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--   # head -->
<!--     group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   ggplot(., aes((t.usage/sum(t.usage)), (pred.cov/sum(pred.cov)))) +  -->
<!--   geom_abline(slope=1, intercept=0, color='red') + -->
<!--   geom_point(alpha=0.2)  -->

<!-- ``` -->


<!-- ```{r} -->
<!-- cele.keqs.myway <- compute.keqs.fixedP(cele.filt.df,prob=rename(primer.usage.cele, primer=hex, p=p.usage), mean.eps = filter(species.epsilons, species=='cele')$eps, take.pairs = T) -->
<!-- zf.keqs.myway <- compute.keqs.fixedP(zf.filt.df,prob=rename(primer.usage.zf, primer=hex, p=p.usage), mean.eps = filter(species.epsilons, species=='zf')$eps, take.pairs = T) -->
<!-- human.keqs.myway <- compute.keqs.fixedP(human.filt.df, mean.eps = filter(species.epsilons, species=='human')$eps, take.pairs = T) -->

<!-- zf.keqs.myway %>% -->
<!--   mutate(phi=p/-single.keq) %>% -->
<!--   # ggplot(., aes(phi)) + geom_histogram(bins=40) -->
<!--   group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--     mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n')) %>% -->
<!--   # ggplot(., aes(sum.phi)) + geom_histogram(bins=40) -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(pred.cov.frac=pred.cov/sum(pred.cov)) %>% -->
<!--   ggplot(., aes(log(t.usage), log(pred.cov))) + geom_point(alpha=0.3) -->

<!-- ``` -->


<!-- ```{r} -->
<!-- primer.usage.d3r <- d3r.all.df %>% -->
<!--   group_by(primer) %>% -->
<!--   summarise(p= sum(pt))  -->
<!-- d3r.keqs.myway <- compute.keqs.fixedP(d3r.filt,mean.eps = 1000, take.pairs = F)  -->

<!-- d3r.pred.cov <- d3r.keqs.myway %>% -->
<!--   # mutate(p = 4/4^6) %>% -->
<!--   filter(pt>20) %>% -->
<!--   # mutate(abundance=abundance/sum(abundance)) %>% -->
<!--   mutate(phi=p*-single.keq) %>% -->
<!--   # ggplot(., aes(phi)) + geom_histogram(bins=40) -->
<!--     group_by(template) %>% -->
<!--   summarise(abundance=first(frac.abundance), epsilon=first(epsilon), t.usage=first(t.usage), sum.phi=sum(phi)) %>% -->
<!--     # ggplot(., aes(sum.phi)) + geom_histogram(bins=40) -->
<!--   # group_by(template) %>% -->
<!--   # # mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(pred.cov=epsilon*(abundance*(sum.phi/(1+sum.phi)))) %>% -->
<!--   mutate(nuc=sapply(template,prevalent_nucleotide), -->
<!--          CG=ifelse(grepl(pattern = 'CG', template), 'y', 'n'))  -->

<!-- d3r.pred.cov %>% -->
<!--   # ggplot(., aes(log(t.usage/sum(t.usage)), log(abundance/sum(abundance)))) +  -->
<!--   ggplot(., aes(log(pred.cov/sum(pred.cov)), log(t.usage/sum(t.usage)))) + -->
<!--   theme_classic() + -->
<!--   geom_point(alpha=0.4, aes(color=nuc, shape=CG)) + -->
<!--     # ggplot(., aes(log(t.usage), log(pred.cov))) +  -->
<!--   geom_abline(slope=1, intercept=0, color='red')  -->

<!-- cor(d3r.pred.cov$pred.cov, d3r.pred.cov$t.usage) -->

<!-- cele.all.df %>% -->
<!--   filter(pt>250) %>% -->
<!--   mutate(a=pt/(abundance*1000-t.usage)) %>% -->
<!--   # ggplot(., aes(a)) + geom_histogram(bins=50)  -->
<!--   ggplot(., aes(dG/0.59, -log(a))) + geom_point(alpha=0.4) -->
<!-- ```  -->